<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Crypto Portfolio Manager</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f9f9f9;
      margin: 0;
      padding: 1em;
    }
    .container {
      max-width: 800px;
      margin: auto;
    }
    h1, h2 {
      text-align: center;
    }
    form {
      background: #eee;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
    }
    form input, form button {
      margin: 5px;
      padding: 8px;
      font-size: 1em;
    }
    form input {
      flex: 1 1 200px;
    }
    form button#addBtn {
      background: #4caf50;
      color: #fff;
      border: none;
      cursor: pointer;
    }
    form button#cancelEdit {
      background: #f44336;
      color: #fff;
      border: none;
      cursor: pointer;
    }
    form button#addBtn:hover, form button#cancelEdit:hover {
      opacity: 0.9;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    thead th {
      background: #333;
      color: #fff;
      padding: 8px;
      text-align: left;
    }
    tbody td {
      padding: 8px;
      border: 1px solid #ccc;
    }
    .actions button {
      margin-right: 5px;
      margin-bottom: 5px;
    }
    .profit-positive {
      color: green;
    }
    .profit-negative {
      color: red;
    }
    /* Responsive table: stack cells vertically on small screens */
    @media (max-width: 600px) {
      table thead {
        display: none;
      }
      table, table tbody, table tr, table td {
        display: block;
        width: 100%;
      }
      table tr {
        margin-bottom: 10px;
        border: 1px solid #ccc;
        padding: 5px;
      }
      table td {
        text-align: right;
        padding: 5px 40% 5px 10px;
        position: relative;
        border: none;
        border-bottom: 1px solid #ccc;
      }
      table td::before {
        content: attr(data-label);
        position: absolute;
        left: 10px;
        top: 5px;
        font-weight: bold;
        text-align: left;
      }
      table td:last-child {
        border-bottom: none;
      }
      .actions {
        text-align: center;
      }
    }
    /* Chart container styling */
    #distributionChart {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Crypto Portfolio Manager</h1>
    <!-- Portfolio Management Section -->
    <section id="portfolio-management">
      <h2>Crypto Portfolio Management</h2>
      <form id="addForm">
        <input type="text" id="name" placeholder="Cryptocurrency (Name or Symbol)" required />
        <input type="number" id="quantity" placeholder="Quantity" step="any" required />
        <input type="number" id="purchasePrice" placeholder="Purchase Price (USD)" step="any" required />
        <input type="number" id="alertPrice" placeholder="Target Alert Price (USD)" step="any" />
        <button type="submit" id="addBtn">Add Cryptocurrency</button>
        <button type="button" id="cancelEdit" style="display:none;">Cancel</button>
      </form>
      <div id="portfolio-list-container">
        <table id="portfolio-table">
          <thead>
            <tr>
              <th>Name</th>
              <th>Quantity</th>
              <th>Purchase Price</th>
              <th>Current Price</th>
              <th>Profit/Loss</th>
              <th>Alert Price</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="portfolio-body"><!-- Portfolio entries will be injected here --></tbody>
        </table>
      </div>
    </section>

    <!-- Portfolio Distribution Chart Section -->
    <section id="distribution-chart-section">
      <h2>Portfolio Distribution</h2>
      <canvas id="distributionChart"></canvas>
    </section>

    <!-- Target Profit Calculator Section -->
    <section id="target-profit-section">
      <h2>Target Profit Calculator</h2>
      <div style="text-align:center; margin-bottom: 10px;">
        <label for="mult1">Multiplier 1:</label>
        <input type="number" id="mult1" value="2" min="1" max="1000" step="any" />
        <label for="mult2">Multiplier 2:</label>
        <input type="number" id="mult2" value="5" min="1" max="1000" step="any" />
        <label for="mult3">Multiplier 3:</label>
        <input type="number" id="mult3" value="10" min="1" max="1000" step="any" />
        <button type="button" id="applyMultipliers">Apply</button>
      </div>
      <div id="target-profit-results"><!-- Profit calculation results will appear here --></div>
    </section>
  </div>

  <!-- Include Chart.js library for pie chart -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Portfolio data array and utility mappings
    const portfolio = [];
    const coinIdMap = {
      "BTC": "bitcoin",
      "ETH": "ethereum",
      "BNB": "binancecoin",
      "XRP": "ripple",
      "ADA": "cardano",
      "DOGE": "dogecoin",
      "MATIC": "matic-network",
      "SOL": "solana",
      "DOT": "polkadot",
      "USDT": "tether",
      "USDC": "usd-coin",
      "BUSD": "binance-usd"
    };
    const chartColors = [
      "#FF6384", "#36A2EB", "#FFCE56", "#4BC0C0", "#9966FF",
      "#FF9F40", "#66FF66", "#FF66FF", "#FFFF66", "#66FFFF"
    ];
    let chart = null;
    let editIndex = null;

    // Render the portfolio table
    function renderPortfolio() {
      const tbody = document.getElementById("portfolio-body");
      tbody.innerHTML = "";
      if (portfolio.length === 0) {
        // Show a message when portfolio is empty
        const row = document.createElement("tr");
        const cell = document.createElement("td");
        cell.setAttribute("colspan", "7");
        cell.style.textAlign = "center";
        cell.textContent = "No cryptocurrencies in portfolio.";
        row.appendChild(cell);
        tbody.appendChild(row);
        return;
      }
      // Populate table with portfolio entries
      portfolio.forEach((coin, idx) => {
        const row = document.createElement("tr");
        row.id = "row-" + idx;
        // Name
        const nameTd = document.createElement("td");
        nameTd.setAttribute("data-label", "Name");
        nameTd.textContent = coin.name;
        row.appendChild(nameTd);
        // Quantity
        const qtyTd = document.createElement("td");
        qtyTd.setAttribute("data-label", "Quantity");
        qtyTd.textContent = coin.quantity;
        row.appendChild(qtyTd);
        // Purchase Price
        const ppTd = document.createElement("td");
        ppTd.setAttribute("data-label", "Purchase Price");
        ppTd.textContent = "$" + Number(coin.purchasePrice).toLocaleString();
        row.appendChild(ppTd);
        // Current Price
        const cpTd = document.createElement("td");
        cpTd.setAttribute("data-label", "Current Price");
        cpTd.textContent = coin.currentPrice !== undefined 
          ? "$" + Number(coin.currentPrice).toLocaleString() 
          : "...";
        row.appendChild(cpTd);
        // Profit/Loss
        const profitTd = document.createElement("td");
        profitTd.setAttribute("data-label", "Profit/Loss");
        if (coin.currentPrice !== undefined) {
          const profit = (coin.currentPrice - coin.purchasePrice) * coin.quantity;
          const profitPct = coin.purchasePrice ? ((coin.currentPrice / coin.purchasePrice - 1) * 100) : 0;
          profitTd.textContent = (profit >= 0 ? "+" : "") + "$" + profit.toFixed(2) + " (" + profitPct.toFixed(2) + "%)";
          profitTd.className = (profit >= 0 ? "profit-positive" : "profit-negative");
        } else {
          profitTd.textContent = "...";
        }
        row.appendChild(profitTd);
        // Alert Price (input field)
        const alertTd = document.createElement("td");
        alertTd.setAttribute("data-label", "Alert Price");
        const alertInput = document.createElement("input");
        alertInput.type = "number";
        alertInput.min = "0";
        alertInput.step = "any";
        alertInput.value = coin.alertPrice !== null && coin.alertPrice !== undefined ? coin.alertPrice : "";
        alertInput.addEventListener("change", () => {
          const val = parseFloat(alertInput.value);
          coin.alertPrice = (!isNaN(val) && val > 0) ? val : null;
          localStorage.setItem("portfolio", JSON.stringify(portfolio));
        });
        alertTd.appendChild(alertInput);
        row.appendChild(alertTd);
        // Actions (Edit/Delete)
        const actionsTd = document.createElement("td");
        actionsTd.setAttribute("data-label", "Actions");
        actionsTd.className = "actions";
        const editBtn = document.createElement("button");
        editBtn.textContent = "Edit";
        editBtn.addEventListener("click", () => {
          // Populate form with selected coin data for editing
          editIndex = idx;
          document.getElementById("name").value = coin.name;
          document.getElementById("quantity").value = coin.quantity;
          document.getElementById("purchasePrice").value = coin.purchasePrice;
          document.getElementById("alertPrice").value = coin.alertPrice ?? "";
          document.getElementById("addBtn").textContent = "Save Changes";
          document.getElementById("cancelEdit").style.display = "inline-block";
          window.scrollTo({ top: 0, behavior: "smooth" }); // scroll up to form
        });
        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "Delete";
        deleteBtn.addEventListener("click", () => {
          if (confirm(`Delete ${coin.name} from portfolio?`)) {
            portfolio.splice(idx, 1);
            localStorage.setItem("portfolio", JSON.stringify(portfolio));
            renderPortfolio();
            updateChart();
            updateTargetProfit();
          }
        });
        actionsTd.appendChild(editBtn);
        actionsTd.appendChild(deleteBtn);
        row.appendChild(actionsTd);
        tbody.appendChild(row);
      });
    }

    // Update or create the distribution pie chart
    function updateChart() {
      const canvas = document.getElementById("distributionChart");
      if (portfolio.length === 0) {
        if (chart) {
          chart.destroy();
          chart = null;
        }
        return;
      }
      // Prepare data for chart
      const labels = portfolio.map(c => c.name);
      const values = portfolio.map(c => c.currentPrice * c.quantity);
      const bgColors = values.map((v, i) => chartColors[i % chartColors.length]);
      if (!chart) {
        // Initialize new chart
        chart = new Chart(canvas, {
          type: "pie",
          data: {
            labels: labels,
            datasets: [{
              data: values,
              backgroundColor: bgColors
            }]
          },
          options: { responsive: true, plugins: { legend: { position: "bottom" } } }
        });
      } else {
        // Update existing chart data
        chart.data.labels = labels;
        chart.data.datasets[0].data = values;
        chart.data.datasets[0].backgroundColor = bgColors;
        chart.update();
      }
    }

    // Calculate and display target profit scenarios
    function updateTargetProfit() {
      const m1 = Math.min(Math.max(parseFloat(document.getElementById("mult1").value) || 1, 1), 1000);
      const m2 = Math.min(Math.max(parseFloat(document.getElementById("mult2").value) || 1, 1), 1000);
      const m3 = Math.min(Math.max(parseFloat(document.getElementById("mult3").value) || 1, 1), 1000);
      // Update input values (in case they were out of bounds)
      document.getElementById("mult1").value = m1;
      document.getElementById("mult2").value = m2;
      document.getElementById("mult3").value = m3;
      const resultsDiv = document.getElementById("target-profit-results");
      if (portfolio.length === 0) {
        resultsDiv.innerHTML = "<p>Add cryptocurrencies to your portfolio to see target profit calculations.</p>";
        return;
      }
      // Build results table
      let html = "<table id='target-table'><thead><tr>";
      html += "<th>Coin</th><th>" + m1 + "x Profit</th><th>" + m2 + "x Profit</th><th>" + m3 + "x Profit</th>";
      html += "</tr></thead><tbody>";
      portfolio.forEach(coin => {
        const targetPrice1 = coin.currentPrice * m1;
        const targetPrice2 = coin.currentPrice * m2;
        const targetPrice3 = coin.currentPrice * m3;
        const profit1 = (targetPrice1 - coin.purchasePrice) * coin.quantity;
        const profit2 = (targetPrice2 - coin.purchasePrice) * coin.quantity;
        const profit3 = (targetPrice3 - coin.purchasePrice) * coin.quantity;
        const profit1Pct = coin.purchasePrice ? ((targetPrice1 / coin.purchasePrice - 1) * 100) : 0;
        const profit2Pct = coin.purchasePrice ? ((targetPrice2 / coin.purchasePrice - 1) * 100) : 0;
        const profit3Pct = coin.purchasePrice ? ((targetPrice3 / coin.purchasePrice - 1) * 100) : 0;
        const profit1Str = (profit1 >= 0 ? "+" : "") + "$" + profit1.toFixed(2) + " (" + profit1Pct.toFixed(2) + "%)";
        const profit2Str = (profit2 >= 0 ? "+" : "") + "$" + profit2.toFixed(2) + " (" + profit2Pct.toFixed(2) + "%)";
        const profit3Str = (profit3 >= 0 ? "+" : "") + "$" + profit3.toFixed(2) + " (" + profit3Pct.toFixed(2) + "%)";
        html += "<tr>";
        html += "<td data-label='Coin'>" + coin.name + "</td>";
        html += "<td data-label='" + m1 + "x Profit'>" + profit1Str + "</td>";
        html += "<td data-label='" + m2 + "x Profit'>" + profit2Str + "</td>";
        html += "<td data-label='" + m3 + "x Profit'>" + profit3Str + "</td>";
        html += "</tr>";
      });
      html += "</tbody></table>";
      resultsDiv.innerHTML = html;
    }

    // Check for price alerts and notify the user
    function checkAlerts() {
      portfolio.forEach((coin, idx) => {
        if (coin.alertPrice && coin.currentPrice >= coin.alertPrice) {
          alert(`${coin.name} has reached the target price of $${coin.alertPrice}!`);
          coin.alertPrice = null;  // clear the alert after triggering
          // Update the alert input field to blank
          const row = document.getElementById("row-" + idx);
          if (row) {
            const alertInput = row.querySelector("td[data-label='Alert Price'] input");
            if (alertInput) alertInput.value = "";
          }
          localStorage.setItem("portfolio", JSON.stringify(portfolio));
        }
      });
    }

    // Fetch current prices for all coins in the portfolio (using CoinGecko API)
    async function refreshPrices() {
      if (portfolio.length === 0) return;
      const idsParam = portfolio.map(c => c.id).join(",");
      try {
        const res = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${idsParam}&vs_currencies=usd`);
        if (!res.ok) return;
        const data = await res.json();
        portfolio.forEach(coin => {
          if (data[coin.id] && data[coin.id].usd !== undefined) {
            coin.currentPrice = data[coin.id].usd;
          }
        });
        localStorage.setItem("portfolio", JSON.stringify(portfolio));
        // Update displayed prices and profit/loss for each coin
        portfolio.forEach((coin, idx) => {
          const row = document.getElementById("row-" + idx);
          if (row) {
            const cpTd = row.querySelector("td[data-label='Current Price']");
            const profitTd = row.querySelector("td[data-label='Profit/Loss']");
            if (cpTd && profitTd) {
              cpTd.textContent = "$" + Number(coin.currentPrice).toLocaleString();
              const profit = (coin.currentPrice - coin.purchasePrice) * coin.quantity;
              const profitPct = coin.purchasePrice ? ((coin.currentPrice / coin.purchasePrice - 1) * 100) : 0;
              profitTd.textContent = (profit >= 0 ? "+" : "") + "$" + profit.toFixed(2) + " (" + profitPct.toFixed(2) + "%)";
              profitTd.className = (profit >= 0 ? "profit-positive" : "profit-negative");
            }
          }
        });
        updateChart();
        updateTargetProfit();
        checkAlerts();
      } catch (err) {
        console.error("Price refresh error:", err);
      }
    }

    // Event listeners
    document.getElementById("applyMultipliers").addEventListener("click", updateTargetProfit);

    document.getElementById("addForm").addEventListener("submit", async (e) => {
      e.preventDefault();
      const nameInput = document.getElementById("name").value.trim();
      const quantityInput = parseFloat(document.getElementById("quantity").value);
      const purchasePriceInput = parseFloat(document.getElementById("purchasePrice").value);
      const alertPriceInput = parseFloat(document.getElementById("alertPrice").value);
      if (!nameInput || isNaN(quantityInput) || isNaN(purchasePriceInput)) {
        alert("Please enter Name, Quantity, and Purchase Price.");
        return;
      }
      if (quantityInput <= 0 || purchasePriceInput <= 0) {
        alert("Quantity and Purchase Price must be positive values.");
        return;
      }
      // Determine CoinGecko ID for the entered coin
      let coinName = nameInput;
      let coinId = coinIdMap[nameInput.toUpperCase()] || null;
      if (!coinId) {
        // Check if input matches a known coin name in our map
        for (let sym in coinIdMap) {
          if (coinIdMap[sym] === nameInput.toLowerCase()) {
            coinId = coinIdMap[sym];
            break;
          }
        }
      }
      if (!coinId) {
        // Use CoinGecko search API as fallback
        try {
          const searchRes = await fetch(`https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(nameInput)}`);
          if (searchRes.ok) {
            const searchData = await searchRes.json();
            if (searchData.coins && searchData.coins.length > 0) {
              coinId = searchData.coins[0].id;
              // Use symbol (uppercase) as display name if available
              coinName = searchData.coins[0].symbol 
                ? searchData.coins[0].symbol.toUpperCase() 
                : searchData.coins[0].name;
            }
          }
        } catch (err) {
          console.error("Search API error:", err);
        }
      }
      if (!coinId) {
        alert("Cryptocurrency not found. Please enter a valid name or symbol.");
        return;
      }
      // Fetch current USD price for the coin
      let currentPrice = null;
      try {
        const priceRes = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`);
        if (priceRes.ok) {
          const priceData = await priceRes.json();
          if (priceData[coinId] && priceData[coinId].usd !== undefined) {
            currentPrice = priceData[coinId].usd;
          }
        }
      } catch (err) {
        console.error("Price fetch error:", err);
      }
      if (currentPrice === null) {
        alert("Unable to fetch current price for the specified cryptocurrency.");
        return;
      }
      // Create or update the coin entry
      const newCoin = {
        id: coinId,
        name: coinName,
        quantity: quantityInput,
        purchasePrice: purchasePriceInput,
        currentPrice: currentPrice,
        alertPrice: (!isNaN(alertPriceInput) && alertPriceInput > 0) ? alertPriceInput : null
      };
      if (editIndex !== null) {
        // Save changes to existing coin
        portfolio[editIndex] = newCoin;
        editIndex = null;
      } else {
        // Add new coin to portfolio
        portfolio.push(newCoin);
      }
      localStorage.setItem("portfolio", JSON.stringify(portfolio));
      renderPortfolio();
      updateChart();
      updateTargetProfit();
      // Reset form to add mode
      document.getElementById("addBtn").textContent = "Add Cryptocurrency";
      document.getElementById("cancelEdit").style.display = "none";
      document.getElementById("addForm").reset();
    });

    document.getElementById("cancelEdit").addEventListener("click", () => {
      editIndex = null;
      document.getElementById("addBtn").textContent = "Add Cryptocurrency";
      document.getElementById("cancelEdit").style.display = "none";
      document.getElementById("addForm").reset();
    });

    // Initialize portfolio from localStorage and start price updates
    document.addEventListener("DOMContentLoaded", () => {
      const stored = localStorage.getItem("portfolio");
      if (stored) {
        try {
          const savedPortfolio = JSON.parse(stored);
          if (Array.isArray(savedPortfolio)) {
            savedPortfolio.forEach(item => {
              if (item.id && item.name && item.quantity !== undefined && item.purchasePrice !== undefined) {
                portfolio.push({
                  id: item.id,
                  name: item.name,
                  quantity: item.quantity,
                  purchasePrice: item.purchasePrice,
                  currentPrice: item.currentPrice || item.purchasePrice, // use stored current or fallback to purchase price
                  alertPrice: item.alertPrice || null
                });
              }
            });
          }
        } catch (err) {
          console.error("Error loading saved portfolio:", err);
        }
      }
      // Initial render
      renderPortfolio();
      updateChart();
      updateTargetProfit();
      // Initial price fetch and periodic refresh
      if (portfolio.length > 0) {
        refreshPrices().catch(err => console.error(err));
      }
      setInterval(refreshPrices, 10000); // auto-refresh prices every 10 seconds
    });
  </script>
</body>
</html>
